##  Bitmap 实现原理
Bitmap 是一种用于位图处理的数据结构，它将每个元素看作是一个二进制位，0 表示未出现，1 表示出现。Bitmap 主要应用于集合操作，如交集、并集、差集等，以及数据统计和过滤等场景。Bitmap 常用的操作有 **set、get、and、or、not** 等，它们都是基于位运算实现的。

Bitmap 的实现原理非常简单，它只需要一个二进制数组来表示一个集合，每个元素对应数组的一个二进制位。


## 如何使用 Redis 的 Bitmap 实现亿级用户签到情况的统计

Redis 是一种高性能的 Key-Value 存储系统，它支持多种数据结构，包括 **String、List、Set、Hash、Zset** 和 **Bitmap** 等。其中，Bitmap 是 Redis 的一种高效的数据结构，它支持高效的位运算操作，可以用于数据统计和过滤等场景。

假设我们需要统计亿级用户的签到情况，这时候，使用 Bitmap 就可以非常方便地实现这个功能。我们可以使用一个长度为 2^32 的 Bitmap 来表示所有的用户，其中每个二进制位表示一个用户是否签到。具体的实现步骤如下：

**1.初始化 Bitmap**

我们可以使用 Redis 的 SETBIT 命令来初始化 Bitmap。例如，我们可以使用以下命令初始化一个长度为 2^32 的 Bitmap：

```
SETBIT sign_in_bitmap 0 0
```

这个命令将第 0 个二进制位设置为 0，即表示第 0 个用户未签到。同理，我们可以使用 **SETBIT** 命令初始化 Bitmap 的其它二进制位。

**2.用户签到**

当用户签到时，我们可以使用 Redis 的 **SETBIT** 命令将对应的二进制位设置为 1。例如，当用户 x 签到时，我们可以使用以下命令将对应的二进制位设置为 1：

```
SETBIT sign_in_bitmap x 1
```


这个命令将 Bitmap 中第 x 个二进制位设置为 1，即表示用户 x 已经签到。

**3.用户签到统计**

当需要统计用户签到情况时，我们可以使用 Redis 的 BITCOUNT 命令统计 Bitmap 中值为 1 的二进制位的数量。例如，我们可以使用以下命令统计 Bitmap 中所有用户的签到情况：

```
BITCOUNT sign_in_bitmap
```

这个命令将返回 Bitmap 中值为 1 的二进制位的数量，即表示签到的用户数量。

使用 Redis 的 Bitmap 来实现用户签到统计非常简单，同时也非常高效。在实际应用中，我们可以根据需要定时清空 Bitmap，以便下一轮统计。下面，我们来看一下使用 Redis 的 Bitmap 实现亿级用户签到情况的内存使用情况示例。

## 内存使用情况示例

假设我们需要统计 10 亿个用户的签到情况，我们可以使用一个长度为 2^32 的 Bitmap 来表示这些用户的签到情况。这个 Bitmap 需要占用的内存空间为：

```
2^32 / 8 / 1024 / 1024 MB = 512 MB
```



即 512 MB。这个内存空间非常小，可以轻松地满足亿级用户签到情况的统计需求。而且，由于 Redis 支持 Bitmap 的持久化存储，我们还可以将 Bitmap 保存到磁盘中，以便下一次使用。

需要注意的是，当用户量增长到更大的规模时，Bitmap 可能会占用更多的内存空间。例如，如果我们需要统计 100 亿个用户的签到情况，那么对应的 Bitmap 需要占用的内存空间将达到：

```
100亿 / 8 / 1024 / 1024 MB = 1192 MB
```


即 1.2 GB。这时候，我们可能需要使用多个 Bitmap 来实现用户签到统计，或者使用其它更加高效的数据结构来解决这个问题。

**以上内存占用只是理论上，实际的 redis 内存占用肯定要大于这个值，因为 redis 一个键值对对象还包括其他信息，也会占用一定的内存。**




## RoaringBitmap
RoaringBitmap是高效压缩位图，简称RBM。
官网介绍：Roaring bitmaps are compressed bitmaps. They can be hundreds of times faster.

RBM的历史并不长，它于2016年由S. Chambi、D. Lemire、O. Kaser等人在论文[《Better bitmap performance with Roaring bitmaps》](https://arxiv.org/pdf/1402.6407.pdf)与[《Consistently faster and smaller compressed bitmaps with Roaring》](https://arxiv.org/pdf/1603.06549.pdf)中提出。
- 将 32bit int（无符号的）类型数据 划分为 2^16 个桶，即最多可能有216=65536个桶，论文内称为container。用container来存放一个数值的低16位。
- 在存储和查询数值时，将数值 k 划分为高 16 位和低 16 位，取高 16 位值找到对应的桶，然后在将低 16 位值存放在相应的 Container 中（存储时如果找不到就会新建一个）。


原始bitmap适用于数据分布比较稠密场景，RoaringBitMap适用于数据分布比较稀疏的场景。




## 布隆过滤器和bitmap区别

布隆过滤器和bitmap都是常见的数据结构，它们都可以用来存储和查询一系列的元素，但是它们之间有一些区别。

1. 存储数据的方式
布隆过滤器使用一个二进制向量来表示存储的数据，每个元素经过多次哈希后，将得到多个哈希值，然后将这些哈希值所对应的位置设为1，即将其添加到布隆过滤器中。

而bitmap使用一个比特位向量来表示存储的数据，每个元素对应一个比特位，如果该元素存在，则将对应的比特位设置为1，否则设置为0。

2. 存储空间的利用率
布隆过滤器在存储相同数量的元素时，相对于bitmap来说，其存储空间通常要小一些。这是因为布隆过滤器使用了多个哈希函数，可以将多个元素映射到同一个比特位上，因此可以用较小的向量来表示相同数量的元素。

3. 数据查询的准确率
布隆过滤器在判断一个元素是否存在时，可能会出现误判的情况，即将一个不存在的元素判断为存在。这是因为多个元素的哈希值可能会映射到同一个比特位上，这样就会造成误判。而bitmap在查询时不会出现误判的情况，因为每个元素只对应一个比特位。

综上所述，布隆过滤器适用于需要存储大量数据，并且对存储空间有要求的场景，例如在网络爬虫中去重，或者在分布式系统中的缓存中使用。而bitmap适用于需要精确查询的场景，例如在计算机系统中的内存管理中使用。




## Bitmap在Java中的应用
**一、40亿数据排序问题**

给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数(在文件中至少缺失这样一个数——为什么？)。在具有足够内存的情况下，如何解决该问题？（编程珠玑）

### 二、应用BitMap存储大数据

数据的存在性可以使用bit位上的1或0来表示；一个bit具有2个值：0和1，正好可以用来表示false和true。

对于判断“数据是否存在”的场景，我们通常使用HashMap来存储，不过hashmap这个数据结构KEY和Value的保存需要消耗较多的内存，不适合保存较多的数据，比如上面的问题中，如果使用哈希表，每条记录保存一个int型的key和一个boolean型的value，  
每条至少需要4字节，假设40亿条数据全部不相同，40亿条记录占据160亿字节，即需要16G内存，明显太高。

如何减少数据占用存储空间可以使用位示图解决，java.util.BitSet可以按位存储，提供了BitMap的典型实现。

> 比如有一堆数字，需要存储，source=[3,5,6,9]  
用int就需要4*4个字节。  
java.util.BitSet可以存true/false。  
如果用java.util.BitSet，则会少很多，其原理是：  
1，先找出数据中最大值maxvalue=9  
2，声明一个BitSet bs,它的size是maxvalue+1=10  
3，遍历数据source，bs[source[i]]设置成true.  
最后的值是：  
(0为false;1为true)  
bs [0,0,0,1,0,1,1,0,0,1]  
3, 5,6, 9  
这样一个本来要int型需要占4字节共32位的数字现在只用了1位，这样就省下了很大空间。


常见的应用场景是那些需要对海量数据进行一些统计工作的时候，比如日志分析、用户数统计等等。  
如统计40亿个数据中没有出现的数据，将40亿个不同数据进行排序等。


参考文章：
1.https://xie.infoq.cn/article/31db0e7e806e703b57faeeb28
2.https://blog.csdn.net/penriver/article/details/119736050
3.https://juejin.cn/s/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8Cbitmap%E5%8C%BA%E5%88%AB
4.https://www.cnblogs.com/binyue/p/5224987.html
