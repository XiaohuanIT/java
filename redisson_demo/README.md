原文来源于 https://blog.csdn.net/sunct/article/details/80178197

具体可见 https://github.com/redisson/redisson/wiki

源码解析

https://juejin.im/post/5ba4b2cc5188255c672eacf2

https://www.jianshu.com/p/a8b3473f9c24







## Why 分布式锁

`java.util.concurrent.locks` 中包含了 JDK 提供的在多线程情况下对共享资源的访问控制的一系列工具，它们可以帮助我们解决进程内多线程并发时的数据一致性问题。

但是在分布式系统中，JDK 原生的并发锁工具在一些场景就无法满足我们的要求了，这就是为什么要使用分布式锁。我总结了一句话，分布式锁是用于解决分布式系统中操作共享资源时的数据一致性问题。

## 设计分布式锁要注意的问题

### 互斥

分布式系统中运行着多个节点，必须确保在同一时刻只能有一个节点的一个线程获得锁，这是最基本的一点。

### 死锁

分布式系统中，可能产生死锁的情况要相对复杂一些。分布式系统是处在复杂网络环境中的，当一个节点获取到锁，如果它在释放锁之前挂掉了，或者因网络故障无法执行释放锁的命令，都会导致其他节点无法申请到锁。

因此分布式锁有必要设置时效，确保在未来的一定时间内，无论获得锁的节点发生了什么问题，最终锁都能被释放掉。

### 性能

对于访问量大的共享资源，如果针对其获取锁时造成长时间的等待，导致大量节点阻塞，是绝对不能接受的。

所以设计分布式锁时要能够掌握锁持有者的动态，若判断锁持有者处于不活动状态，要能够强制释放其持有的锁。
 此外，排队等待锁的节点如果不知道锁何时会被释放，则只能隔一段时间尝试获取一次锁，这样无法保证资源的高效利用，因此当锁释放时，要能够通知等待队列，使一个等待节点能够立刻获得锁。

### 重入

考虑到一些应用场景和资源的高效利用，锁要设计成可重入的，就像 JDK 中的 ReentrantLock 一样，同一个线程可以重复拿到同一个资源的锁。



这里以 `lock()` 方法为例，其他一系列方法与其核心实现基本一致。

##### 先来看 *lock()* 的基本用法



```source-java
RLock lock = redisson.getLock("foobar"); // 1.获得锁对象实例
lock.lock(); // 2.获取分布式锁
try {
    // do sth.
} finally {
    lock.unlock(); // 3.释放锁
}
```

1. 通过 RedissonClient 的 `getLock()` 方法取得一个 *RLock* 实例。
2. `lock()` 方法尝试获取锁，如果成功获得锁，则继续往下执行，否则等待锁被释放，然后再继续尝试获取锁，直到成功获得锁。
3. `unlock()` 方法释放获得的锁，并通知等待的节点锁已释放。



redisson支持4种链接redis的方式：

Cluster(集群)

Sentinel servers(哨兵)

Master/Slave servers(主从)

Single server(单机)


测试结果

```
======lock======Thread-91
======获得锁后进行相应的操作======
======unlock======Thread-91
=============================
======lock======Thread-63
======获得锁后进行相应的操作======
======unlock======Thread-63
=============================
======lock======Thread-31
======获得锁后进行相应的操作======
======unlock======Thread-31
=============================
======lock======Thread-97
======获得锁后进行相应的操作======
======unlock======Thread-97
=============================
======lock======Thread-8
======获得锁后进行相应的操作======
======unlock======Thread-8
=============================
```



链接：https://www.jianshu.com/p/a8b3473f9c24





因为redisson是基于java的网络编程框架netty实现，所以首先提供了暴露了netty相关配置参数；


对于redission的watch dog，lock的时候，就不要加过期时间了。